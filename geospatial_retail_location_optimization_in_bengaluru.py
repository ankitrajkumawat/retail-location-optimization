# -*- coding: utf-8 -*-
"""Geospatial Retail Location Optimization in Bengaluru.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/178JS2OqlReIUowcmdfSwmxNIhQvTSX3V
"""

!pip install --upgrade --force-reinstall osmnx

import osmnx as ox
import geopandas as gpd
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestRegressor
import folium
from shapely.geometry import Point, Polygon

# Configure OSMnx
ox.settings.log_console = True
ox.settings.use_cache = True
ox.settings.timeout = 300  # Increase timeout for large queries

# Step 1: Get Bengaluru's boundary
def get_city_boundary():
    place_name = "Bengaluru, Karnataka, India"
    try:
        city = ox.geocode_to_gdf(place_name)
        return city
    except Exception as e:
        print(f"Error fetching city boundary: {e}")
        return None

# Step 2: Get road network (simplified)
def get_road_network():
    place_name = "Bengaluru, Karnataka, India"
    try:
        G = ox.graph_from_place(place_name, network_type='drive', simplify=True)
        return G
    except Exception as e:
        print(f"Error fetching road network: {e}")
        return None

# Step 3: Get Points of Interest with geometry filtering
def get_competitors(poi_type='cafe'):
    tags = {'amenity': poi_type}
    try:
        competitors = ox.features_from_place("Bengaluru, Karnataka, India", tags=tags)
        # Filter only Point geometries
        competitors = competitors[competitors.geometry.type == 'Point'].copy()
        if len(competitors) == 0:
            raise ValueError("No Point geometries found for competitors")
        return competitors
    except Exception as e:
        print(f"Error fetching competitors: {e}")
        return None

# Step 4: Competitor Density Analysis with safe coordinate extraction
def analyze_competitor_density(competitors):
    try:
        # Safely extract coordinates
        competitors['x'] = competitors.geometry.apply(lambda geom: geom.x)
        competitors['y'] = competitors.geometry.apply(lambda geom: geom.y)
        coordinates = competitors[['x', 'y']].values

        # Cluster competitors
        if len(coordinates) < 5:  # Handle case with few competitors
            competitors['cluster'] = 0
            return competitors, np.array([[coordinates.mean(axis=0)]])

        kmeans = KMeans(n_clusters=min(5, len(coordinates)), random_state=42)
        competitors['cluster'] = kmeans.fit_predict(coordinates)

        return competitors, kmeans.cluster_centers_
    except Exception as e:
        print(f"Error in competitor analysis: {e}")
        return None, None

# Step 5: Road Network Analysis with error handling
def analyze_road_network(G):
    try:
        if G is None:
            raise ValueError("No road network provided")

        # Calculate centrality
        centrality = nx.closeness_centrality(G)

        # Convert to GeoDataFrame
        nodes = ox.graph_to_gdfs(G, edges=False)
        nodes['centrality'] = centrality.values()

        return nodes
    except Exception as e:
        print(f"Error in road network analysis: {e}")
        return None

# Step 6: Prepare ML Dataset with bounds checking
def prepare_ml_data(competitors, nodes, city_boundary):
    try:
        if competitors is None or nodes is None:
            raise ValueError("Missing input data")

        # Use city boundary if available, otherwise competitor bounds
        if city_boundary is not None:
            bbox = city_boundary.total_bounds
        else:
            bbox = competitors.total_bounds

        # Create sample grid points
        x = np.linspace(bbox[0], bbox[2], 20)
        y = np.linspace(bbox[1], bbox[3], 20)
        xx, yy = np.meshgrid(x, y)
        grid_points = [Point(x, y) for x, y in zip(xx.flatten(), yy.flatten())]

        # Create features for each point
        data = []
        for point in grid_points:
            # Distance to nearest competitor
            distances = competitors.geometry.distance(point)
            min_dist = distances.min() if len(distances) > 0 else 1000

            # Road centrality
            if nodes is not None and len(nodes) > 0:
                nearest_node = nodes.geometry.distance(point).idxmin()
                centrality = nodes.loc[nearest_node, 'centrality']
            else:
                centrality = 0.5  # Default value

            # Population density (placeholder)
            population_density = np.random.randint(1000, 10000)

            data.append({
                'geometry': point,
                'distance_to_competitor': min_dist,
                'road_centrality': centrality,
                'population_density': population_density
            })

        return gpd.GeoDataFrame(data, crs="EPSG:4326")
    except Exception as e:
        print(f"Error preparing ML data: {e}")
        return None

# Step 7: Train ML Model with validation
def train_model(gdf):
    try:
        if gdf is None or len(gdf) == 0:
            raise ValueError("No data for model training")

        # Generate target variable
        gdf['sales_potential'] = (
            100 - gdf['distance_to_competitor']/100 +
            gdf['road_centrality'] * 50 +
            gdf['population_density']/500
        ).clip(0, 100)

        # Prepare features and target
        X = gdf[['distance_to_competitor', 'road_centrality', 'population_density']]
        y = gdf['sales_potential']

        # Train model
        model = RandomForestRegressor(random_state=42)
        model.fit(X, y)

        # Predict
        gdf['predicted_sales'] = model.predict(X)

        return model, gdf
    except Exception as e:
        print(f"Error in model training: {e}")
        return None, None

# Step 8: Visualize Results with fallbacks
def visualize_results(city, competitors, clusters, gdf):
    try:
        # Create base map centered on Bengaluru
        m = folium.Map(location=[12.9716, 77.5946], zoom_start=12)

        # Add city boundary if available
        if city is not None:
            folium.GeoJson(city).add_to(m)

        # Add competitors if available
        if competitors is not None and len(competitors) > 0:
            for _, row in competitors.iterrows():
                folium.CircleMarker(
                    location=[row.geometry.y, row.geometry.x],
                    radius=3,
                    color='red',
                    fill=True,
                    popup=f"Competitor (Cluster {row.get('cluster', 'N/A')})"
                ).add_to(m)

        # Add cluster centers if available
        if clusters is not None and len(clusters) > 0:
            for center in clusters:
                if len(center) >= 2:  # Ensure we have x,y coordinates
                    folium.CircleMarker(
                        location=[center[1], center[0]],
                        radius=10,
                        color='blue',
                        fill=True,
                        popup="Cluster Center"
                    ).add_to(m)

        # Add predicted locations if available
        if gdf is not None and len(gdf) > 0:
            top_locations = gdf.nlargest(int(len(gdf)*0.05), 'predicted_sales')
            for _, row in top_locations.iterrows():
                folium.CircleMarker(
                    location=[row.geometry.y, row.geometry.x],
                    radius=5,
                    color='green',
                    fill=True,
                    popup=f"Potential Location (Score: {row['predicted_sales']:.1f})"
                ).add_to(m)

        return m
    except Exception as e:
        print(f"Error in visualization: {e}")
        return None

# Main execution with error handling
if __name__ == "__main__":
    print("Starting Bengaluru Retail Location Analysis...")

    # Get data
    print("\n1. Fetching city boundary...")
    city = get_city_boundary()

    print("\n2. Fetching road network...")
    G = get_road_network()

    print("\n3. Fetching competitor locations...")
    competitors = get_competitors(poi_type='cafe')

    # Analyze data
    print("\n4. Analyzing competitor density...")
    competitors, cluster_centers = analyze_competitor_density(competitors)

    print("\n5. Analyzing road network...")
    nodes = analyze_road_network(G)

    print("\n6. Preparing ML dataset...")
    ml_data = prepare_ml_data(competitors, nodes, city)

    # Train model
    print("\n7. Training model...")
    model, ml_data = train_model(ml_data)

    # Visualize
    print("\n8. Generating visualization...")
    map_result = visualize_results(city, competitors, cluster_centers, ml_data)

    if map_result is not None:
        map_result.save('optimal_locations.html')
        print("\nAnalysis Complete!")
        print(f"Total competitors analyzed: {len(competitors) if competitors is not None else 0}")
        if ml_data is not None:
            print(f"Top predicted location score: {ml_data['predicted_sales'].max():.1f}")
        print("Interactive map saved to 'optimal_locations.html'")
    else:
        print("\nAnalysis failed - could not generate results")

# Complete Geospatial Retail Location Analysis for Bengaluru with Timeout Handling
import osmnx as ox
import geopandas as gpd
import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
from sklearn.ensemble import RandomForestRegressor
import folium
from shapely.geometry import Point, Polygon
import multiprocessing
from functools import partial
import time

# Configure OSMnx
ox.settings.log_console = True
ox.settings.use_cache = True
ox.settings.timeout = 300

# Step 1: Get Bengaluru's boundary
def get_city_boundary():
    place_name = "Bengaluru, Karnataka, India"
    try:
        city = ox.geocode_to_gdf(place_name)
        print("Successfully fetched city boundary")
        return city
    except Exception as e:
        print(f"Error fetching city boundary: {e}")
        return None

# Step 2: Get road network (simplified)
def get_road_network():
    place_name = "Bengaluru, Karnataka, India"
    try:
        print("Downloading road network...")
        G = ox.graph_from_place(
            place_name,
            network_type='drive',
            simplify=True,
            retain_all=False,
            truncate_by_edge=True
        )
        print(f"Successfully fetched road network with {len(G)} nodes")
        return G
    except Exception as e:
        print(f"Error fetching road network: {e}")
        return None

# Step 3: Get Points of Interest with geometry filtering
def get_competitors(poi_type='cafe'):
    tags = {'amenity': poi_type}
    try:
        print(f"Fetching {poi_type} locations...")
        competitors = ox.features_from_place("Bengaluru, Karnataka, India", tags=tags)
        # Filter only Point geometries
        competitors = competitors[competitors.geometry.type == 'Point'].copy()
        if len(competitors) == 0:
            raise ValueError("No Point geometries found for competitors")
        print(f"Found {len(competitors)} competitors")
        return competitors
    except Exception as e:
        print(f"Error fetching competitors: {e}")
        return None

# Step 4: Competitor Density Analysis with safe coordinate extraction
def analyze_competitor_density(competitors):
    try:
        if competitors is None or len(competitors) == 0:
            raise ValueError("No competitors provided")

        print("Analyzing competitor density...")
        # Safely extract coordinates
        competitors['x'] = competitors.geometry.apply(lambda geom: geom.x)
        competitors['y'] = competitors.geometry.apply(lambda geom: geom.y)
        coordinates = competitors[['x', 'y']].values

        # Cluster competitors
        n_clusters = min(5, len(coordinates))
        if n_clusters < 1:
            competitors['cluster'] = 0
            return competitors, np.array([])

        kmeans = KMeans(n_clusters=n_clusters, random_state=42)
        competitors['cluster'] = kmeans.fit_predict(coordinates)

        print(f"Competitors clustered into {n_clusters} groups")
        return competitors, kmeans.cluster_centers_
    except Exception as e:
        print(f"Error in competitor analysis: {e}")
        return None, None

# Step 5: Road Network Analysis with timeout
def analyze_road_network_worker(G):
    """Worker function to be run in separate process"""
    try:
        start_time = time.time()
        print("Calculating centrality...")
        centrality = nx.closeness_centrality(G)
        print("Converting to GeoDataFrame...")
        nodes = ox.graph_to_gdfs(G, edges=False)
        nodes['centrality'] = centrality.values()
        print(f"Road analysis completed in {time.time()-start_time:.1f} seconds")
        return nodes
    except Exception as e:
        print(f"Error in road network analysis: {e}")
        return None

def analyze_road_network(G, timeout=600):  # 10 minute timeout
    """Analyze road network with timeout protection"""
    if G is None:
        print("No road network provided - skipping analysis")
        return None

    print(f"Starting road network analysis (timeout: {timeout} seconds)...")

    # Create a worker process
    pool = multiprocessing.Pool(processes=1)
    try:
        # Start the analysis in a separate process
        async_result = pool.apply_async(analyze_road_network_worker, (G,))

        # Wait with timeout
        nodes = async_result.get(timeout=timeout)
        pool.close()
        pool.join()

        if nodes is not None:
            print(f"Successfully analyzed {len(nodes)} road nodes")
        else:
            print("Road network analysis returned no results")

        return nodes

    except multiprocessing.TimeoutError:
        print(f"Road network analysis timed out after {timeout} seconds")
        pool.terminate()
        pool.join()

        # Return partial results if possible by doing a quick simplified analysis
        print("Attempting simplified analysis with first 1000 nodes...")
        try:
            subgraph = G.subgraph(list(G.nodes())[:1000])
            centrality = nx.closeness_centrality(subgraph)
            nodes = ox.graph_to_gdfs(subgraph, edges=False)
            nodes['centrality'] = centrality.values()
            print(f"Returning partial results for {len(nodes)} nodes")
            return nodes
        except Exception as e:
            print(f"Simplified analysis failed: {e}")
            return None

    except Exception as e:
        print(f"Error in road network analysis: {e}")
        pool.terminate()
        pool.join()
        return None

# Step 6: Prepare ML Dataset with bounds checking
def prepare_ml_data(competitors, nodes, city_boundary):
    try:
        if competitors is None or len(competitors) == 0:
            raise ValueError("No competitors provided")

        print("Preparing ML dataset...")
        # Use city boundary if available, otherwise competitor bounds
        if city_boundary is not None:
            bbox = city_boundary.total_bounds
        else:
            bbox = competitors.total_bounds

        # Create sample grid points
        x = np.linspace(bbox[0], bbox[2], 20)
        y = np.linspace(bbox[1], bbox[3], 20)
        xx, yy = np.meshgrid(x, y)
        grid_points = [Point(x, y) for x, y in zip(xx.flatten(), yy.flatten())]

        # Create features for each point
        data = []
        for point in grid_points:
            # Distance to nearest competitor
            distances = competitors.geometry.distance(point)
            min_dist = distances.min() if len(distances) > 0 else 1000

            # Road centrality
            if nodes is not None and len(nodes) > 0:
                nearest_node = nodes.geometry.distance(point).idxmin()
                centrality = nodes.loc[nearest_node, 'centrality']
            else:
                centrality = 0.5  # Default value

            # Population density (placeholder)
            population_density = np.random.randint(1000, 10000)

            data.append({
                'geometry': point,
                'distance_to_competitor': min_dist,
                'road_centrality': centrality,
                'population_density': population_density
            })

        ml_data = gpd.GeoDataFrame(data, crs="EPSG:4326")
        print(f"Prepared ML dataset with {len(ml_data)} locations")
        return ml_data
    except Exception as e:
        print(f"Error preparing ML data: {e}")
        return None

# Step 7: Train ML Model with validation
def train_model(gdf):
    try:
        if gdf is None or len(gdf) == 0:
            raise ValueError("No data for model training")

        print("Training ML model...")
        # Generate target variable
        gdf['sales_potential'] = (
            100 - gdf['distance_to_competitor']/100 +
            gdf['road_centrality'] * 50 +
            gdf['population_density']/500
        ).clip(0, 100)

        # Prepare features and target
        X = gdf[['distance_to_competitor', 'road_centrality', 'population_density']]
        y = gdf['sales_potential']

        # Train model
        model = RandomForestRegressor(random_state=42)
        model.fit(X, y)

        # Predict
        gdf['predicted_sales'] = model.predict(X)

        print("Model training completed")
        return model, gdf
    except Exception as e:
        print(f"Error in model training: {e}")
        return None, None

# Step 8: Visualize Results with fallbacks
def visualize_results(city, competitors, clusters, gdf):
    try:
        print("Generating visualization...")
        # Create base map centered on Bengaluru
        m = folium.Map(location=[12.9716, 77.5946], zoom_start=12)

        # Add city boundary if available
        if city is not None:
            folium.GeoJson(city).add_to(m)

        # Add competitors if available
        if competitors is not None and len(competitors) > 0:
            for _, row in competitors.iterrows():
                folium.CircleMarker(
                    location=[row.geometry.y, row.geometry.x],
                    radius=3,
                    color='red',
                    fill=True,
                    popup=f"Competitor (Cluster {row.get('cluster', 'N/A')})"
                ).add_to(m)

        # Add cluster centers if available
        if clusters is not None and len(clusters) > 0:
            for center in clusters:
                if len(center) >= 2:  # Ensure we have x,y coordinates
                    folium.CircleMarker(
                        location=[center[1], center[0]],
                        radius=10,
                        color='blue',
                        fill=True,
                        popup="Cluster Center"
                    ).add_to(m)

        # Add predicted locations if available
        if gdf is not None and len(gdf) > 0:
            top_locations = gdf.nlargest(int(len(gdf)*0.05), 'predicted_sales')
            for _, row in top_locations.iterrows():
                folium.CircleMarker(
                    location=[row.geometry.y, row.geometry.x],
                    radius=5,
                    color='green',
                    fill=True,
                    popup=f"Potential Location (Score: {row['predicted_sales']:.1f})"
                ).add_to(m)

        print("Visualization generated")
        return m
    except Exception as e:
        print(f"Error in visualization: {e}")
        return None

# Main execution with error handling
if __name__ == "__main__":
    print("Starting Bengaluru Retail Location Analysis...\n")
    start_time = time.time()

    # Get data
    city = get_city_boundary()
    G = get_road_network()
    competitors = get_competitors(poi_type='cafe')

    # Analyze data
    competitors, cluster_centers = analyze_competitor_density(competitors)
    nodes = analyze_road_network(G, timeout=600)  # 10 minute timeout
    ml_data = prepare_ml_data(competitors, nodes, city)

    # Train model
    model, ml_data = train_model(ml_data)

    # Visualize
    map_result = visualize_results(city, competitors, cluster_centers, ml_data)

    if map_result is not None:
        map_result.save('optimal_locations.html')
        print("\nAnalysis Complete!")
        print(f"Total execution time: {time.time()-start_time:.1f} seconds")
        print(f"Total competitors analyzed: {len(competitors) if competitors is not None else 0}")
        if ml_data is not None:
            print(f"Top predicted location score: {ml_data['predicted_sales'].max():.1f}")
        print("Interactive map saved to 'optimal_locations.html'")
    else:
        print("\nAnalysis failed - could not generate results")

